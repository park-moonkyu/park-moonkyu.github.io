<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://park-moonkyu.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://park-moonkyu.github.io//" rel="alternate" type="text/html" /><updated>2021-01-21T22:13:02+09:00</updated><id>https://park-moonkyu.github.io//feed.xml</id><title type="html">꾸준하게 정리하기</title><subtitle>주니어 개발자 박문규의 블로그입니다.</subtitle><author><name>Moonkyu Park</name></author><entry><title type="html">DRM 이란 ?</title><link href="https://park-moonkyu.github.io//drm/drm/" rel="alternate" type="text/html" title="DRM 이란 ?" /><published>2021-01-21T00:00:00+09:00</published><updated>2021-01-22T01:07:00+09:00</updated><id>https://park-moonkyu.github.io//drm/drm</id><content type="html" xml:base="https://park-moonkyu.github.io//drm/drm/">&lt;p&gt;DRM 이란 ?&lt;/p&gt;

&lt;p&gt;DRM(Digit Rights Management)은 ‘디지털 저작권 권리’라고 해석된다.
디지털 환경에서 콘텐츠를 만들어낸 이의 지적 재산권 보호를 한다.
또한 해당 창작물을 사용하고자 하는 사용자의 의무와 권리를 보호하기 위한 기술이다.&lt;/p&gt;

&lt;p&gt;오프라인 제품이 도매 소매를 거치는 유통라인처럼 온라인도 유사한 절차를 거친다.
따라서 이러한 보호/판매/운영을 위해서는 DRM솔루션 제품이 포함된 서비스를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://blog.kollus.com/wp-content/uploads/2014/04/DRM-%ED%8C%A8%ED%82%A4%EC%A7%95-%EB%9D%BC%EC%9D%B4%EC%84%BC%EC%8B%B1-%ED%9D%90%EB%A6%84%EB%8F%84.png&quot; alt=&quot;title&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;책같은 경우, 책을 디지털 콘텐츠로 변환한 후 DRM처리하여 변환하는 작업을 한다.
이때 작업과정을 패키징(packaging)이라고 하고 패키징하는 도구는 패키저(Packager)이다.&lt;/p&gt;

&lt;p&gt;패키징은은 시점을 기준으로 2가지로 나뉜다.
사용자가 콘텐츠를 요청한 시점(on-the-flay-packaging)과 사전에 패키징하는 (pre-packaging)이다.
문서파일이나 음원 파일 같은 경우에는 실시간 패키징을 하게된다.
동영상이나 게임 설치 프로그램과 같은 경우 사전에 한다.&lt;/p&gt;

&lt;p&gt;콘텐츠 사용규칙에 맞게 구매한 구매자는 단말기기에 DRM복호화 모듈이 존재해야한다.
이 모듈의 역할을 사용자 인증과 라이선스 정보를 발급받아 컨텐츠 복호화이다.&lt;/p&gt;</content><author><name>Moonkyu Park</name></author><category term="DRM" /><category term="인턴공부" /><summary type="html">DRM(Digit Rights Management)은 '디지털 저작권 권리'라고 해석된다.</summary></entry><entry><title type="html">쿠버네티스란 ?</title><link href="https://park-moonkyu.github.io//kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4(1)/" rel="alternate" type="text/html" title="쿠버네티스란 ?" /><published>2021-01-20T00:00:00+09:00</published><updated>2021-01-21T01:07:00+09:00</updated><id>https://park-moonkyu.github.io//kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4(1)</id><content type="html" xml:base="https://park-moonkyu.github.io//kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4(1)/">&lt;h2 id=&quot;유래&quot;&gt;유래&lt;/h2&gt;

&lt;p&gt;키잡이(선박의 방향을 바꾸기 위하여 사용하는 장치를 도작 하는 선원) 이나 파일럿을 뜻하는 그리스어에서 유래하였다. &lt;br /&gt;왜 키잡이, 파일럿이라는 단어가 나왔을까? 차근차근 알아보도록 하자 !&lt;br /&gt;
구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화하였다. &lt;br /&gt;15년 이상의 구글의 경험과 다양한 커뮤니티가 만나면서 커뮤니티 최고의 아이디어와 적용 사례가 결합되며 더욱더 커지고 있다.&lt;/p&gt;

&lt;h2 id=&quot;시간의-흐름에-따른-변화&quot;&gt;시간의 흐름에 따른 변화&lt;/h2&gt;
&lt;p&gt;시간이 흐르면서 쿠버네티스가 왜 필요성이 대두되었는지 알아보기 위해 다양한 배포 방법을 알아보자.
&lt;img src=&quot;https://d33wubrfki0l68.cloudfront.net/26a177ede4d7b032362289c6fccd448fc4a91174/eb693/images/docs/container_evolution.svg&quot; alt=&quot;title&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
&lt;center&gt; &amp;lt;출처 : kubernetes 문서&amp;gt;&lt;/center&gt;

&lt;h3 id=&quot;전통적인-배포시대&quot;&gt;&lt;strong&gt;전통적인 배포시대&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;초기 조직은 애플리케이션을 물리서버에서 실행했다. 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제가 발생했다. 애플리케이션 중에서는 엄청 무거운 즉, 리소스를 전부 차지하는 인스턴스가 있을수 있고, 그럴 경우 성능이 저하된다. 이에 대한 해결책은 서로 다른 여러 물리 서버 여러대를 두는것이다. 그러나 이러한 해결책은 리소스가 충분히 활용되지 않는다는 점에서 물리 서버를 많이 유지하기 위해 조직에게 많은 비용이 들었다.&lt;/p&gt;

&lt;h3 id=&quot;가상화된-배포시대&quot;&gt;&lt;strong&gt;가상화된 배포시대&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;위의 해결책으로 가상화가 도입되었다. 단일 물리 서버의 CPU에서 여러 가상 시스템(VM)을 실행할 수 있게 한다.
가상화를 사용하면 VM간에 애플리케이션을 격리가능하다. 어느정도 보안성도 제공하는 것이다.&lt;br /&gt;&lt;br /&gt;
가상화를 통해 리소스를 효율적으로 사용가능하고 용이하게 애플리케이션 추가 및 업데이트가 가능하다.
&lt;br /&gt;&lt;br /&gt; 각각의 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성요소를 실행하는 완전한 머신이다.&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;컨테이너-개발시대&quot;&gt;&lt;strong&gt;컨테이너 개발시대&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간 운영체제를 공유한다.&lt;br /&gt;
그러므로 더 가볍다고 여겨진다.&lt;br /&gt;
VM과 마찬가지로 컨테이너는 자체 파일 시스템, CPU, 메모리, 프로세스가 있다.&lt;br /&gt;
기본 인프라와 종속성을 끊어 클라우드나 OS 배포에 인식 가능하다.&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;VM 이미지를 사용하는것에 비해 컨테이너 이미지가 생성이 쉽게 효율적&lt;/li&gt;
  &lt;li&gt;안정적으고 주기적으로 컨테이너 이미지를 빌드 및 배포 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;왜-필요한가-&quot;&gt;왜 필요한가 ?&lt;/h2&gt;
&lt;p&gt;컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법이다.&lt;br /&gt;
이러한 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가용성을 확인해야한다.&lt;br /&gt;
컨테이너가 실행중 다운되면 빠르게 다른 컨테이너를 다시 시작해야하는것이 하나의 예시이다.&lt;br /&gt;
이러한 문제를 시스템에 의해 처리하면 좋지 않을까 ?&lt;br /&gt;
이것이 쿠버네티스가 필요한 이유이다!!!&lt;br /&gt;
쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다.&lt;br /&gt;
애플리케이션의 확장과 장애 조치를 처리하고 배포 패턴 등을 제공한다.&lt;br /&gt;
&lt;br /&gt; 쿠버네티스가 제공하는 것들&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Service discovery &amp;amp; Load Balancing&lt;br /&gt;
쿠버네티스는 DNS이름 혹은 자체IP로 컨테이너 노출 가능하다. 트래픽이 많으면 로드밸런싱을 한다.&lt;/li&gt;
  &lt;li&gt;Storage Orchestration&lt;br /&gt;
로컬 저장소, 공용 클라우드 공급자등과 같이 원하는 저장소 시스템을 자동으로 탑재 가능하다.&lt;/li&gt;
  &lt;li&gt;자동화된 롤아웃과 롤백&lt;br /&gt;
쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제고하고 모든 리소스를 새 컨테이너에 적용 할 수 있다.
    &lt;h2 id=&quot;쿠버네티스가-아닌-것&quot;&gt;쿠버네티스가 아닌 것&lt;/h2&gt;
    &lt;p&gt;쿠버네티스는 모든 것이 포함된(PaaS)가 아니다. &lt;br /&gt;
쿠버네티스는 하드웨어 수준보다는 컨테이너 수준에서 운영된다.&lt;br /&gt;
PaaS가 제공하는 배포,스케일링,밸런싱과 같은 기능을 제공한다.&lt;br /&gt;
하지만 쿠버네티스는 모놀리식(monolithic)이 아니여서 추가나 제거가 용이.&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;지원하는 애플리케이션의 유형을 제약하지 않는다.&lt;/li&gt;
  &lt;li&gt;소스 코드를 배포하지않으며 애플리케이션을 빌드하지 않는다.&lt;/li&gt;
  &lt;li&gt;애플리케이션 레벨의 서비스를 제공하지 않는다.&lt;/li&gt;
  &lt;li&gt;로깅 모니터링 또는 경보 솔류션을 포함하지 않는다.&lt;/li&gt;
  &lt;li&gt;기본 설정 언어 및 시스템을 제공하거나 요구하지 않는다.&lt;br /&gt;
쿠버네티스는 단순한 오케스트레이션 시스템이 아니다.&lt;br /&gt;
쿠버네티스는 오케스트레이션의 필요성을 없애준다.&lt;br /&gt;
오케스트레이션의 기술적인 정의는 A를 먼저하고 B, C를 하는것처럼 정의된 워크플로르를 수행하는 것이다.&lt;br /&gt;
반면 쿠버네티스는 독립적이고 조합 가능한 제어 프로세스들로 구성된다.&lt;br /&gt;
현재 상태를 입력받은 의도한 상태로 나아가도록 한다.&lt;br /&gt;
A 에서 C로 어떻게 갔는지는 상관이 없고 중앙화된 제어도 필요하지 않다.&lt;br /&gt;
이로써 시스템이 보다 더 사용하기 용이하고 강력하다.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moonkyu Park</name></author><category term="kubernetes" /><category term="인턴공부" /><summary type="html">쿠베네티스 개요에 대해서 알아보자</summary></entry><entry><title type="html">캐글 가이드</title><link href="https://park-moonkyu.github.io//%EB%8F%85%EC%84%9C/%EC%BA%90%EA%B8%80%EA%B0%80%EC%9D%B4%EB%93%9C/" rel="alternate" type="text/html" title="캐글 가이드" /><published>2021-01-18T00:00:00+09:00</published><updated>2019-04-17T22:06:00+09:00</updated><id>https://park-moonkyu.github.io//%EB%8F%85%EC%84%9C/%EC%BA%90%EA%B8%80%EA%B0%80%EC%9D%B4%EB%93%9C</id><content type="html" xml:base="https://park-moonkyu.github.io//%EB%8F%85%EC%84%9C/%EC%BA%90%EA%B8%80%EA%B0%80%EC%9D%B4%EB%93%9C/">&lt;p&gt;&lt;img src=&quot;https://search.pstatic.net/common/?src=http%3A%2F%2Fshop1.phinf.naver.net%2F20200701_2%2F1593587692923oRvKv_JPEG%2F1052217653831685_1523104267.jpg&amp;amp;type=a340&quot; alt=&quot;title&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;캐글가이드---사카모토-유시도키&quot;&gt;캐글가이드 - 사카모토 유시도키&lt;/h2&gt;

&lt;h4 id=&quot;기간--20210112---20210117&quot;&gt;기간 : 2021.01.12 - 2021.01.17&lt;/h4&gt;

&lt;p&gt;지금까지 캐글코리아에서 활동을 하며 제대로된 캐글 활동을 해오진 않았다.
도서지원을 받을 기회가 생겨 무슨책을 고를까 고민하다가 고른책들 중 한권이다.
올해는 캐글에서 다양한 활동을 하고싶어 워밍업 차원으로 읽은 느낌도 있다.&lt;/p&gt;

&lt;p&gt;책은 캐글을 완전 처음 접해보는 사람을 대상으로 하고 있다.
또한 캐글은 어떠한 사이트인지, 어떠한 목적으로 사용을하는지 등 다양한 목적이 나와있다.&lt;/p&gt;

&lt;p&gt;흐름은 캐글을 어떻게 사용하는지(캐글 노트북, discussion, submit 등) 소개하고 다양한 캐글대회들을 소개한다.
또한 캐글을 통해서 해당분야의 발전을 알수있다고 한다.&lt;/p&gt;

&lt;p&gt;예를 들면 자연어 처리가. 단순한 LSTM에서 Bert까지 등장하는 노트북을 소개한다.&lt;/p&gt;

&lt;p&gt;올해 목표는 캐글 expert가 되는것이다. 
지금 이 포스팅이 어떻게 보면 이 블로그의 첫번째 포스팅인데 꾸준하게 공부하며 기록을 해보도록 해야겠다.&lt;/p&gt;</content><author><name>Moonkyu Park</name></author><category term="독서" /><category term="독서" /><summary type="html">사카모토 도시유키 지음 / 박광수 옮김&quot;</summary></entry><entry><title type="html">github.io 블로그 시작하기</title><link href="https://park-moonkyu.github.io//blog/first-post/" rel="alternate" type="text/html" title="github.io 블로그 시작하기" /><published>2021-01-11T00:00:00+09:00</published><updated>2021-01-11T22:17:00+09:00</updated><id>https://park-moonkyu.github.io//blog/first-post</id><content type="html" xml:base="https://park-moonkyu.github.io//blog/first-post/">&lt;p&gt;GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.
GitHub Blog 서비스의 이름은 Pages이다.&lt;/p&gt;

&lt;p&gt;Pages가 다른 블로그 플랫폼 보다 편한 것 같아서 마음에 든다.
다른 사람들도 같이 많이 사용했으면 좋겠다는 생각이 든다.&lt;/p&gt;

&lt;p&gt;YFM에서 정의한 제목을 이중 괄호 구문으로 본문에 추가할 수 있다.
이 글의 제목은 github.io 블로그 시작하기이고
마지막으로 수정된 시간은 2021-01-11 08:17:00 -0500이다.&lt;/p&gt;</content><author><name>Moonkyu Park</name></author><category term="Blog" /><category term="Blog" /><summary type="html">GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.</summary></entry></feed>