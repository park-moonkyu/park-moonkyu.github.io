I"<h2 id="유래">유래</h2>

<p>키잡이(선박의 방향을 바꾸기 위하여 사용하는 장치를 도작 하는 선원) 이나 파일럿을 뜻하는 그리스어에서 유래하였다. <br />왜 키잡이, 파일럿이라는 단어가 나왔을까? 차근차근 알아보도록 하자 !<br />
구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화하였다. <br />15년 이상의 구글의 경험과 다양한 커뮤니티가 만나면서 커뮤니티 최고의 아이디어와 적용 사례가 결합되며 더욱더 커지고 있다.</p>

<h2 id="시간의-흐름에-따른-변화">시간의 흐름에 따른 변화</h2>
<p>시간이 흐르면서 쿠버네티스가 왜 필요성이 대두되었는지 알아보기 위해 다양한 배포 방법을 알아보자.
<img src="https://d33wubrfki0l68.cloudfront.net/26a177ede4d7b032362289c6fccd448fc4a91174/eb693/images/docs/container_evolution.svg" alt="title" class="align-center" /></p>
<center> &lt;출처 : kubernetes 문서&gt;</center>

<h3 id="전통적인-배포시대"><strong>전통적인 배포시대</strong></h3>
<p>초기 조직은 애플리케이션을 물리서버에서 실행했다. 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제가 발생했다. 애플리케이션 중에서는 엄청 무거운 즉, 리소스를 전부 차지하는 인스턴스가 있을수 있고, 그럴 경우 성능이 저하된다. 이에 대한 해결책은 서로 다른 여러 물리 서버 여러대를 두는것이다. 그러나 이러한 해결책은 리소스가 충분히 활용되지 않는다는 점에서 물리 서버를 많이 유지하기 위해 조직에게 많은 비용이 들었다.</p>

<h3 id="가상화된-배포시대"><strong>가상화된 배포시대</strong></h3>
<p>위의 해결책으로 가상화가 도입되었다. 단일 물리 서버의 CPU에서 여러 가상 시스템(VM)을 실행할 수 있게 한다.
가상화를 사용하면 VM간에 애플리케이션을 격리가능하다. 어느정도 보안성도 제공하는 것이다.<br /><br />
가상화를 통해 리소스를 효율적으로 사용가능하고 용이하게 애플리케이션 추가 및 업데이트가 가능하다.
<br /><br /> 각각의 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성요소를 실행하는 완전한 머신이다.<br /></p>

<h3 id="컨테이너-개발시대"><strong>컨테이너 개발시대</strong></h3>
<p>컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간 운영체제를 공유한다.<br />
그러므로 더 가볍다고 여겨진다.<br />
VM과 마찬가지로 컨테이너는 자체 파일 시스템, CPU, 메모리, 프로세스가 있다.<br />
기본 인프라와 종속성을 끊어 클라우드나 OS 배포에 인식 가능하다.<br /></p>
<ul>
  <li>VM 이미지를 사용하는것에 비해 컨테이너 이미지가 생성이 쉽게 효율적</li>
  <li>안정적으고 주기적으로 컨테이너 이미지를 빌드 및 배포 가능</li>
</ul>

<h2 id="왜-필요한가-">왜 필요한가 ?</h2>
<p>컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법이다.<br />
이러한 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가용성을 확인해야한다.<br />
컨테이너가 실행중 다운되면 빠르게 다른 컨테이너를 다시 시작해야하는것이 하나의 예시이다.<br />
이러한 문제를 시스템에 의해 처리하면 좋지 않을까 ?<br />
이것이 쿠버네티스가 필요한 이유이다!!!<br />
쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다.<br />
애플리케이션의 확장과 장애 조치를 처리하고 배포 패턴 등을 제공한다.<br />
<br /> 쿠버네티스가 제공하는 것들</p>
<ul>
  <li>Service discovery &amp; Load Balancing<br />
쿠버네티스는 DNS이름 혹은 자체IP로 컨테이너 노출 가능하다. 트래픽이 많으면 로드밸런싱을 한다.</li>
  <li>Storage Orchestration<br />
로컬 저장소, 공용 클라우드 공급자등과 같이 원하는 저장소 시스템을 자동으로 탑재 가능하다.</li>
  <li>자동화된 롤아웃과 롤백<br />
쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제고하고 모든 리소스를 새 컨테이너에 적용 할 수 있다.
    <h2 id="쿠버네티스가-아닌-것">쿠버네티스가 아닌 것</h2>
    <p>쿠버네티스는 모든 것이 포함된(PaaS)가 아니다. <br />
쿠버네티스는 하드웨어 수준보다는 컨테이너 수준에서 운영된다.<br />
PaaS가 제공하는 배포,스케일링,밸런싱과 같은 기능을 제공한다.<br />
하지만 쿠버네티스는 모놀리식(monolithic)이 아니여서 추가나 제거가 용이.<br /></p>
  </li>
  <li>지원하는 애플리케이션의 유형을 제약하지 않는다.</li>
  <li>소스 코드를 배포하지않으며 애플리케이션을 빌드하지 않는다.</li>
  <li>애플리케이션 레벨의 서비스를 제공하지 않는다.</li>
  <li>로깅 모니터링 또는 경보 솔류션을 포함하지 않는다.</li>
  <li>기본 설정 언어 및 시스템을 제공하거나 요구하지 않는다.<br />
쿠버네티스는 단순한 오케스트레이션 시스템이 아니다.<br />
쿠버네티스는 오케스트레이션의 필요성을 없애준다.<br />
오케스트레이션의 기술적인 정의는 A를 먼저하고 B, C를 하는것이다.<br />
반면 쿠버네티스는 독립적이고 조합 가능한 제어 프로세스들로 구성된다.<br />
현재 상태를 입력받은 의도한 상태로 나아가도록 한다.<br />
A 에서 C로 어떻게 갔는지는 상관이 없고 중앙화된 제어도 필요하지 않다.<br />
이로써 시스템이 보다 더 사용하기 용이하고 강력하다.<br /></li>
</ul>
:ET